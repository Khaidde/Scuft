Point => type {
    x: num;
    y: num;
    z: num;
}
Particle => type {
    point: Point;
    existence: bool = true;
    glowing: bool;
    name: string;
    message = "facets";
}

test => module {
    add = (a: num, b: num) -> num {
        return a + b;
    }
    booolerrr: \(bool, bool, num, num) -> bool = (a: bool, b: bool, x: Astrology.Star, y: num) -> bool {
        return x > y $$ a && b || (a || b);

        if (3 < 4) doSomething(); else doOtherThing();
        while true doSomething();
        for i in x.array doSomething();
        lambda = \a, b => a * b;

        func = () doThing(-1, 2);
        funcWithParam = (a: num, b: num) doThing(a, b);

        funcWithParamAndReturn = (a: num, b: num) -> num return doThing(a, b);

        for i in #range [0, 10) {
            //0...9
            break;
        }
        for i in #range (0, 10) {
            //1...9

            continue;
            break;
        }
        for i in #range (0, 10] {
            //1...10
        }
        for i in #range [0, 10] {
            //0...10
            construct = 3 + Astrology.Star.Proton.{ intersting <- true, notInteresting <- false }; 
            test.thing.x = new * 3 - particle.pos.x + 2;
            thingyVar.that.this.random.bar(cool, 3);
        }
        for list {

        }
        for others, other in Astrology.starArray {

        }
        for item, index in array {

        }
        return d;
    }
    Vector4 => type {
        w: num;
        x: num;
        y: num;
        z: num;
    }
    combine = (a: Vector4, b: Vector4) -> Vector4 {
        return a + b;
    }
}

Astrology => module {
    stars = 5000;
    ageOfUniverse = 6000;
    findDate = (a: num) -> num {
        return ageOfUniverse;
    }
    Constellation => type {
        name: string;
        starsCount: num;
        isItGood: bool;
        interpretation: string;
    }
    meaning = (a: Constellation) -> Constellation {
        nothing = Constellation.{
            name       <- "nothing",
            starsCount <- 3 + func(3, 4 + 5) + 5
        };
        while 3 < 2  {
            if 3 < 4 {
                return "thisOrThat";
            } else if 3 != 4 {
                d = 90;
                return d;
            } else {
                return "k";
            }
        }
        return nothing;
    }
}

main = () -> num {
    with Astrology;
    with test;
    a: Point;
    b: constellation;
    q = meaning(b);
    l: Vector4;
    l': Vector4;
    dl = combine(l, -l');
    
    thing.thing = \(num, num) -> thing().cool;

    for test in #range [-2 + x, 345.6 + "test" * -5 - 6 - sin(cos(x), y) ^ 3) {

    }
    for item in #range [3 + 35, strLength) {

    }
    for item in array {
        item = item + 1;
    }
    tester = 3 + test.(3 + 2).nice() + (\x, y => x + y + 3) (4, 5); 
    test3 = 4 * 8 . x; 
    test53 = 3 + s.4 (3);

    testtest = thing.other.call() << 3;
    testOther = \x,y => x ^ y;
}

test2 => module {
    with Astrology;
    x = 3 + 5 - 6;
    func = () {
        do.stuff();
    }
    var = 3.2+ 4;
}

testExpr = Math.test + Point.{x <- 3, y <- 2}.name.test().other * cool;
point = Point.{
    x <- 3,
    y <- 2
};

testParticle = Particle.{
    point <- Point.{
        x <- 3,
        y <- 4
    }
};

testMod => module {
    funct = () {
        doThing()
        if true {
            continue
        }
