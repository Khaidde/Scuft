1/4/21 (Monday)
    Tasks
    - Remove absolute value bars 
    - Refactor the function overloading in scope to make parsing errors nicer
    - Implement operator keyword for operator overloading 
    - Fix the cycle checker to work for the following case: d = g; g = f; f = g;
        - Similar issue is seen with: Particle = type { point: Particle; }
    - Create error handling function to print recurse stacks
    - Handle mismatch in assignment types in the type checker: For example: a: ~num => 3;  b: getConstType() ~= 6;
    - Currently, function overloads are stored as ASTDeclarations. Maybe change this to be cleaner/memory efficient

    Ideas
        Operator overloads are allowed in modules
            Astrology = module {
                Particle = type {

                }
                operator * => () {

                }
            }

            with Astrology;
            p = Particle.{} + Particle.{};

    Small Tasks
    - Fixed the cycle checker to work for "typeOfExpression"
    - Fixed the scope with function overloading stuff. Scope now stores a map from variables (strings) to a list of declarations
    - Implemented preliminary type checking for blocks (only checks for statements right now)
    - Implemented error checking for mutable, immutable and const assignment
        - Defer a lot of declaration error checking until type checking
        - "Variable reassignment is not allowed in global scope"
        - "Module can't contain variable reassignments"/"Duplicate variable declaration"
        - "Type definition can't contain variable reassignments"/"Duplicate variable declaration"
    - Recursive type definitions now work (scopes of type definitions store a reference to the type definition)
        ListItem = type {
            value: num;
            nextItem: ListItem;
        }
    - Error is throw with recursive type construction
        ListItem = type {
            value: num;
            nextItem: ListItem = ListItem.{}; //An error is throw because of infinite recursion
        }
    - Changed bitwise operators to "|", "&" and "$" for bitwise "or", "and" and "xor" respectively

    Done
    - ASTCall mostly works
        - Get function Signature / Declaration does its job but may require refactoring later
    - Operator overloading now type checks using operators in global scope and generalized default operator case

1/5/21 (Tuesday)
    Tasks
    - Refactoring everything to line up with the organization in typechecking
    - Make operator keyword in lexer store the name of the identifier in the token: "operator newThing" is stored as a token
    - Fix issue where if an operator overload is not used, it won't be type checked
    - Create better error output for mismatched types in binary operator: a = 3 + "String" (where add operator is not overloaded)
        - Make an error handling method to output "wholeNode"
    - Implement the checking for mutable, immutable and constant cases
    - Implement scope stuff for "with" keyword
    - Dot Operator Case (Mayur)
    - Function typechecking (in OngoingTODO) 
        - Pure function detection
        - Return case (possibly also handle checking branches?)
        - Declaration case (make sure not already defined)
    - Start basic evaluation 
        - Use this to implement resolveType for metaprogramming cases
    - Implement ordered immutable declarations
        - if () {
            a = e; // this should fail
          }
          e = 3;

    Ideas
        Changes to const and mutable assignment syntax
            a: const num;
            func => (a: mut num ~= 3, b: const Particle) -> const string {
                a += 5;
                output: const string => a + b.x;
                return output;
            }
        Type unions (Kind of hard to implement)
            a: mut num | mut string;
            a ~= 3;
            a ~= "random";
    Issues
        Consider the following for overloaded functions
            add = (a = 3, b = 6) -> num {
                test2 => 2;
            }

            add = (a: string, b: string) -> string {

            }

            test = add;
            test(3, 4);

            //Should the following be allowed
            testNum: \(num, num) -> num = add;
            test(3, 4); //works
            test("Thing", "other"); //throws an error
        Consider the following for function overloads
            add: num;
            add = (a:num, b:num) -> num {
                return a + b;
            }

    Small Tasks
    - Fixed lexer/error handler error where error indicators were of the wrong length
    - Implemented access casts for types to const and mut

    Done
    - Dealt with scope stuff for declarations
        - Ensured that mutable and immutable variables are declared in ordered
        - Developed mutual understanding of what the declared variable was among all assignments which referenced it
    - Dealt with mutable and constant assignment issues. 
        - For example: casting the "5" in "a: const num = 5" to "const num"
        -            : casting the "true" in "b: mut bool = true" to "mut bool"
    - Caught a lot of bugs and did error handling for specific edge cases
    - Wrote down beginnings of Final Test Code
        - Discussed how the vector syntax may look in the future. 

1/6/21 (Wednesday)
    Tasks
    - Refactor stuff (it's pretty ugly)
    - Detect pure functions (isConstant function)
    - Fixing function overloading to work with assignment
        add = () {}
        add = (a: num) {}
        func = add;
        func();
    - Constant folding on everything
        a: getNum() = 3 + 60; is replaced with a: num = 63;
        - Related to constant function evaluation
        - Related to dot operators/references
    - Return statements/branch checking need to be typechecked
    - With statements and discuss more about how they work with other things
    - All statements: if/elseif/while/for

    Ideas 
        Translating operators in modules into global scope
            Math => module {
                Point => type {
                    x: num;
                    y: num;
                }
                operator + => (a: Point, b: Point) -> Point {
                    ...
                }
                print => (a: Point) -> string {
                    ...
                }
            }

            p0 = Math.Point.{};
            p1 = Math.Point.{};
            p2 = p0 + p1;
            str = Math.print(p0);

            // Operator gets translated to the following:
            operator + => (a: Math.Point, b: Math.Point) -> Math.Point {
                ...
            }
            Math => module {
                Point => type {
                    x: num;
                    y: num;
                }
                print => (a: Point) -> string {
                    ...
                }
            }
        Switch pattern matching
            main = () {
                out = switch x {
                        32 -> {
                            a: num = 3;
                            return 2 + a;
                        }
                        45 || 64 -> return 3;
                        x > 100 ->  return 4;
                }
            }

        Enums

            Color => enum {
                RED => 1,
                BLUE,        //2
                GREEN => 12
                ORANGE,      //13
            }

            favoriteColor: Color = RED;

        Null reference alternatives
            add (?, 4);
            add = (a: num, b = 3) -> num {

            }

            add = (a: maybe const num, b => 3) -> maybe const num {
                x = 3423;

                result ~= b;
                switch a.fold {
                    some -> {
                        result += a.some;
                        return;
                    }
                    none -> {
                        result = 0;
                        return;
                    }
                }
                return b + 1;
            }

            
            Maybe = type {
                t: type;
                value: t;
                fold = () -> t | nothing {

                }
            }
            
            Maybe.{ t <- num}

            class Maybe<T> {
                private T value;
            }

            Maybe<int> thingy = new Maybe<int>();
            thingy.value = 3;
        
        Polymorphism
            print = (a: #T, b: T, c: #G) -> G {
                if (a < b) {
                    return c;
                }
            }
            operator < => (a: string, b: string) -> bool {
                return false;
            }
            print ("string", "asdf", 3);

        For loop range (REVAMPED)
            count = 3;
            for i in_range [0, 8) {
                count += count;
            }

        Compiler Directives (REVAMPED)
            squarePlusOne = (x: num) <- 3 * x + 4;

            squarePlusOne' = @derive x squarePlusOne
    
